<html>

<head>
	<title>defineProperty</title>
</head>

<body>
	<!-- <a href="https://blog.csdn.net/liwusen/article/details/79387083">https://blog.csdn.net/liwusen/article/details/79387083</a> -->
	<!-- <br> -->
	<a href="https://www.dazhuanlan.com/2020/02/02/5e36e8ffdcf48/">2、define property，setter，getter</a>
	<br>
	<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a>
	<br>
	<p>百度 defineProperty prototype</p>

	<p>Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符.(自有属性指的是直接赋予该对象的属性,不需要从原型链上进行查找的属性)</p>

	<script type="text/javascript">
		"use strict"

		//Object.defineProperty(String.prototype, 'myLength', {
		//	get: function() {
		//		return this.length;
		//	},
		//});
		//
		//var a = "12345"
		//
		//console.log(a.myLength)

		function Observer(data) {
			this.data = data;
			this.walk(data);
		};

		// 此函数用于深层次遍历对象的各个属性
		// 采用的是递归的思路
		// 因为我们要为对象的每一个属性绑定getter和setter
		Observer.prototype.walk = function (obj) {
			let val;
			for (let key in obj) {
				// 这里为什么要用hasOwnProperty进行过滤呢？
				// 因为for...in 循环会把对象原型链上的所有可枚举属性都循环出来
				// 而我们想要的仅仅是这个对象本身拥有的属性，所以要这么做。
				if (obj.hasOwnProperty(key)) {
					val = obj[key];

					// 这里进行判断，如果还没有遍历到最底层，继续new Observer
					if (typeof val === 'object') {
						new Observer(val);
					}

					this.convert(key, val);
				}
			}
		};

		Observer.prototype.convert = function (key, val) {
			Object.defineProperty(this.data, key, {
				enumerable: true,
				configurable: true,
				get: function () {
					console.log('你访问了' + key);
					return val
				},
				set: function (newVal) {
					console.log('你设置了' + key);
					console.log('新的' + key + ' = ' + newVal)
					if (newVal === val) return;
					val = newVal
				}
			})
		};

		let data = {
			user: {
				name: "liangshaofeng",
				age: "24"
			},
			address: {
				city: "beijing"
			}
		};

		let app = new Observer(data);
		// console.log(app)

		function section0() {
			let _obj = {
				_val: null
			}

			Object.defineProperty(_obj, "val", {
				get(value) {
					console.log("get", value)
					return this._val;
				},
				set(newValue) {
					console.log("set", newValue)
					this._val = newValue;
				},
				enumerable: true,
				configurable: true
			});
			_obj.val = 1
			console.log(_obj.val)
		}

		function section1() {
			let _obj = {}
			let descriptor = Object.create(null) // 相当于没有 __proto__ 的 {}
			descriptor.value = 1

			// 默认 false, 写不写都一样
			// descriptor.writable = false
			// descriptor.enumerable = false
			// descriptor.configurable = false

			Object.defineProperty(_obj, "val", descriptor);

			console.log("_obj: 对象")
			console.log("\"val\": 对象的属性名")
			console.log("descriptor: 对象的属性的描述符")
			console.log("descriptor.value: 对象的属性的描述符的特性")

		}

		function section2() {
			let _obj = {}

			Object.defineProperty(_obj, "val", {
				value: "val 未修改",
				// writable: false,
				// enumerable: false,
				configurable: false
			});
			Object.defineProperty(_obj, "val2", {
				value: "val2 未修改",
				// writable: false,
				// enumerable: false,
				configurable: true
			});
			try {
				Object.defineProperty(_obj, "val", {
					value: "val 修改",
				});
			} catch (error) {
				console.log("[val] configurable: false, 该属性的描述符不可以修改")
			}

			Object.defineProperty(_obj, "val2", {
				value: "val2 修改",
			});

			try {
				delete _obj.val
			} catch (error) {
				console.log("[val] configurable: false, 该属性不可以被 delete")
			}

			console.log(_obj.val)
			console.log(_obj.val2)

			delete _obj.val2

			console.log(_obj.val2)
			// val2 被 delete 了

			// 描述符不可以修改指, 除了 writable: true 改 false, [value, writable, configurable, enumerable, get, set] 都不可以修改
			// 前后值相同不算"修改"
		}

		function section3() {
			let _obj = {}

			Object.defineProperty(_obj, "val", {
				value: "val 未修改",
				writable: false,
				// enumerable: false,
				// configurable: false,
			});

			try {
				_obj.val = "val 修改"
			} catch (error) {
				console.log("[val] writable: false, 该属性不能被重新赋值")
			}

			console.log(_obj.val)

		}

		function section4() {
			let _obj = {}

			Object.defineProperty(_obj, "val", {
				value: "val enumerable: false",
				// writable: false,
				enumerable: false,
				// configurable: false,
			});
			Object.defineProperty(_obj, "val2", {
				value: "val2 enumerable: true",
				// writable: false,
				enumerable: true,
				// configurable: false,
			});

			for (var i in _obj) {
				console.log(_obj[i]);
			}
			console.log(Object.keys(_obj))

			_obj.propertyIsEnumerable("val") // false
			_obj.propertyIsEnumerable("val2") // true

			console.log("[val] enumerable: false, 该属性不能被[for in], Objeck.keys() 等循环方法枚举")

		}

		function section5() {
			function myclass() { }

			myclass.prototype.x = 1;
			Object.defineProperty(myclass.prototype, "y", {
				writable: false,
				value: 1
			});

			var a = new myclass();
			a.x = 2;
			console.log(a.x); // 2
			console.log(myclass.prototype.x); // 1

			console.log(a)
			console.log(myclass.prototype)

			// a.y = 2; // Ignored, throws in strict mode
			// console.log(a.y); // 1
			// console.log(myclass.prototype.y); // 1
		}

		// section1()
		// section2()
		// section3()
		// section4()
		section5()

		console.log("怎么查看属性的描述符的特性")
	</script>
</body>

</html>