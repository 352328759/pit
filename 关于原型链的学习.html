<html>

<head>
	<title>关于原型链的学习</title>
</head>

<body>
	<a href="https://blog.csdn.net/liwusen/article/details/79387083">https://blog.csdn.net/liwusen/article/details/79387083</a>
	<br>
	<a href="https://www.dazhuanlan.com/2020/02/02/5e36e8ffdcf48/">https://www.dazhuanlan.com/2020/02/02/5e36e8ffdcf48/</a>
	<br>
	<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a>
	<br>
	<p>百度 defineProperty prototype</p>

	<script type="text/javascript">
		//Object.defineProperty(String.prototype, 'myLength', {
		//	get: function() {
		//		return this.length;
		//	},
		//});
		//
		//var a = "12345"
		//
		//console.log(a.myLength)

		var Father = function Father(name) {
			this.name = name
		}
		Father.prototype.p1 = "实例化前 Father.prototype"
		var son = new Father("1")
		var son2 = new Father("2")
		Father.prototype.p2 = "实例化后 Father.prototype"
		son.__proto__.p3 = "实例化后 son.__proto__"

		// 这两个不是计算结果, 而是工作原理
		// console.log(Father.prototype === son.__proto__); //true
		// console.log(Father.prototype.constructor === Father); //true

		// Father 本质是 Function new 出来的对象, 就像 son 由 Father new 出来一样
		// console.log(Function.prototype === Father.__proto__); //true

		// son 本身没有 constructor, 没有就会沿原型链向上找, 也就是 son.__proto__[.__proto__ ...], 直到 "找到" 或 "没有更多的.__proto__"
		// 本例 son.constructor 实际上是沿原型链往上一层的 son.__proto__.constructor
		// console.log(son === son.__proto__); //false
		// console.log(son.constructor === son.__proto__.constructor); //true
		// console.log(son.constructor === son.__proto__.__proto__.constructor); //false
		// console.log(Object === son.__proto__.__proto__.constructor); //true

		console.log(Object.__proto__.constructor === Object)
		console.log(2)


		console.log(Object === Father.prototype.__proto__.constructor); //true
		// console.log(Function.prototype === Father.__proto__); //true
		// console.log(Object.prototype === Function.__proto__); //false
		console.log(Function.prototype === Function.__proto__); //true
		console.log(Function.prototype === Object.__proto__); //true
		console.log(Function.__proto__ === Object.__proto__); //true
		console.log(Object.prototype === Object.__proto__); //false
		console.log(Father.__proto__ === Function.__proto__); //true

		console.log(Object.prototype === Father.__proto__.__proto__); //true
		console.log(Object.prototype === Function.prototype.__proto__); //true

		// console.log(Function.__proto__)





		console.log(1)

		// 根据以上条件, 结合简单的换算可以发现以下及更多全等关系
		console.log(Father.prototype === son.constructor.prototype); //true
		console.log(Father.prototype.constructor === son.__proto__.constructor)



			// console.log(Father.prototype.p1); // 实例化前 Father.prototype
			// console.log(son.p1); // 实例化前 Father.prototype
			// console.log(son2.p1); // 实例化前 Father.prototype

			// console.log(Father.prototype.p2); // 实例化后 Father.prototype
			// console.log(son.p2); // 实例化后 Father.prototype
			// console.log(son2.p2); // 实例化后 Father.prototype

			// console.log(Father.prototype.p3); // 实例化后 son.__proto__
			// console.log(son.p3); // 实例化后 son.__proto__
			// console.log(son2.p3); // 实例化后 son.__proto__


			// console.log(son)
			// console.log(son2._p)
			// console.log(son.__proto__._p)
	</script>
</body>

</html>